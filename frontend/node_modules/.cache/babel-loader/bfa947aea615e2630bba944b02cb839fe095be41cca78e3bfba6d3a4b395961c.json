{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  isHangingPromiseRejectionError: null,\n  makeHangingPromise: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  isHangingPromiseRejectionError: function () {\n    return isHangingPromiseRejectionError;\n  },\n  makeHangingPromise: function () {\n    return makeHangingPromise;\n  }\n});\nfunction isHangingPromiseRejectionError(err) {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false;\n  }\n  return err.digest === HANGING_PROMISE_REJECTION;\n}\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION';\nclass HangingPromiseRejectionError extends Error {\n  constructor(expression) {\n    super(`During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`), this.expression = expression, this.digest = HANGING_PROMISE_REJECTION;\n  }\n}\nfunction makeHangingPromise(signal, expression) {\n  const hangingPromise = new Promise((_, reject) => {\n    signal.addEventListener('abort', () => {\n      reject(new HangingPromiseRejectionError(expression));\n    }, {\n      once: true\n    });\n  });\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject);\n  return hangingPromise;\n}\nfunction ignoreReject() {}","map":{"version":3,"names":["isHangingPromiseRejectionError","makeHangingPromise","err","digest","HANGING_PROMISE_REJECTION","HangingPromiseRejectionError","Error","constructor","expression","signal","hangingPromise","Promise","_","reject","addEventListener","once","catch","ignoreReject"],"sources":["C:\\Users\\DELL\\node_modules\\next\\src\\server\\dynamic-rendering-utils.ts"],"sourcesContent":["export function isHangingPromiseRejectionError(\n  err: unknown\n): err is HangingPromiseRejectionError {\n  if (typeof err !== 'object' || err === null || !('digest' in err)) {\n    return false\n  }\n\n  return err.digest === HANGING_PROMISE_REJECTION\n}\n\nconst HANGING_PROMISE_REJECTION = 'HANGING_PROMISE_REJECTION'\n\nclass HangingPromiseRejectionError extends Error {\n  public readonly digest = HANGING_PROMISE_REJECTION\n\n  constructor(public readonly expression: string) {\n    super(\n      `During prerendering, ${expression} rejects when the prerender is complete. Typically these errors are handled by React but if you move ${expression} to a different context by using \\`setTimeout\\`, \\`after\\`, or similar functions you may observe this error and you should handle it in that context.`\n    )\n  }\n}\n\n/**\n * This function constructs a promise that will never resolve. This is primarily\n * useful for dynamicIO where we use promise resolution timing to determine which\n * parts of a render can be included in a prerender.\n *\n * @internal\n */\nexport function makeHangingPromise<T>(\n  signal: AbortSignal,\n  expression: string\n): Promise<T> {\n  const hangingPromise = new Promise<T>((_, reject) => {\n    signal.addEventListener(\n      'abort',\n      () => {\n        reject(new HangingPromiseRejectionError(expression))\n      },\n      { once: true }\n    )\n  })\n  // We are fine if no one actually awaits this promise. We shouldn't consider this an unhandled rejection so\n  // we attach a noop catch handler here to suppress this warning. If you actually await somewhere or construct\n  // your own promise out of it you'll need to ensure you handle the error when it rejects.\n  hangingPromise.catch(ignoreReject)\n  return hangingPromise\n}\n\nfunction ignoreReject() {}\n"],"mappings":";;;;;;;;;;;;;;;;EAAgBA,8BAA8B,WAAAA,CAAA;WAA9BA,8BAAA;;EA6BAC,kBAAkB,WAAAA,CAAA;WAAlBA,kBAAA;;;AA7BT,SAASD,+BACdE,GAAY;EAEZ,IAAI,OAAOA,GAAA,KAAQ,YAAYA,GAAA,KAAQ,QAAQ,EAAE,YAAYA,GAAE,GAAI;IACjE,OAAO;EACT;EAEA,OAAOA,GAAA,CAAIC,MAAM,KAAKC,yBAAA;AACxB;AAEA,MAAMA,yBAAA,GAA4B;AAElC,MAAMC,4BAAA,SAAqCC,KAAA;EAGzCC,YAAYC,UAAkC,EAAE;IAC9C,KAAK,CACH,wBAAwBA,UAAA,wGAAkHA,UAAA,uJAAiK,QAFnRA,UAAA,GAAAA,UAAA,OAFZL,MAAA,GAASC,yBAAA;EAMzB;AACF;AASO,SAASH,mBACdQ,MAAmB,EACnBD,UAAkB;EAElB,MAAME,cAAA,GAAiB,IAAIC,OAAA,CAAW,CAACC,CAAA,EAAGC,MAAA;IACxCJ,MAAA,CAAOK,gBAAgB,CACrB,SACA;MACED,MAAA,CAAO,IAAIR,4BAAA,CAA6BG,UAAA;IAC1C,GACA;MAAEO,IAAA,EAAM;IAAK;EAEjB;EACA;EACA;EACA;EACAL,cAAA,CAAeM,KAAK,CAACC,YAAA;EACrB,OAAOP,cAAA;AACT;AAEA,SAASO,aAAA,GAAgB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}