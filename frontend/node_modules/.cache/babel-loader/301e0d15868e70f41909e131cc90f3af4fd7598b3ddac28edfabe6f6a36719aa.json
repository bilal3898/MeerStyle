{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n0 && (module.exports = {\n  getExpectedRequestStore: null,\n  getHmrRefreshHash: null,\n  getPrerenderResumeDataCache: null,\n  getRenderResumeDataCache: null,\n  workUnitAsyncStorage: null\n});\nfunction _export(target, all) {\n  for (var name in all) Object.defineProperty(target, name, {\n    enumerable: true,\n    get: all[name]\n  });\n}\n_export(exports, {\n  getExpectedRequestStore: function () {\n    return getExpectedRequestStore;\n  },\n  getHmrRefreshHash: function () {\n    return getHmrRefreshHash;\n  },\n  getPrerenderResumeDataCache: function () {\n    return getPrerenderResumeDataCache;\n  },\n  getRenderResumeDataCache: function () {\n    return getRenderResumeDataCache;\n  },\n  workUnitAsyncStorage: function () {\n    return _workunitasyncstorageinstance.workUnitAsyncStorageInstance;\n  }\n});\nconst _workunitasyncstorageinstance = require(\"./work-unit-async-storage-instance\");\nfunction getExpectedRequestStore(callingExpression) {\n  const workUnitStore = _workunitasyncstorageinstance.workUnitAsyncStorageInstance.getStore();\n  if (workUnitStore) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore;\n    }\n    if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-ppr' || workUnitStore.type === 'prerender-legacy') {\n      // This should not happen because we should have checked it already.\n      throw Object.defineProperty(new Error(`\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`), \"__NEXT_ERROR_CODE\", {\n        value: \"E401\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n    if (workUnitStore.type === 'cache') {\n      throw Object.defineProperty(new Error(`\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E37\",\n        enumerable: false,\n        configurable: true\n      });\n    } else if (workUnitStore.type === 'unstable-cache') {\n      throw Object.defineProperty(new Error(`\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`), \"__NEXT_ERROR_CODE\", {\n        value: \"E69\",\n        enumerable: false,\n        configurable: true\n      });\n    }\n  }\n  throw Object.defineProperty(new Error(`\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`), \"__NEXT_ERROR_CODE\", {\n    value: \"E251\",\n    enumerable: false,\n    configurable: true\n  });\n}\nfunction getPrerenderResumeDataCache(workUnitStore) {\n  if (workUnitStore.type === 'prerender' || workUnitStore.type === 'prerender-ppr') {\n    return workUnitStore.prerenderResumeDataCache;\n  }\n  return null;\n}\nfunction getRenderResumeDataCache(workUnitStore) {\n  if (workUnitStore.type !== 'prerender-legacy' && workUnitStore.type !== 'cache' && workUnitStore.type !== 'unstable-cache') {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore.renderResumeDataCache;\n    }\n    // We return the mutable resume data cache here as an immutable version of\n    // the cache as it can also be used for reading.\n    return workUnitStore.prerenderResumeDataCache;\n  }\n  return null;\n}\nfunction getHmrRefreshHash(workUnitStore) {\n  var _workUnitStore_cookies_get;\n  return workUnitStore.type === 'cache' ? workUnitStore.hmrRefreshHash : workUnitStore.type === 'request' ? (_workUnitStore_cookies_get = workUnitStore.cookies.get('__next_hmr_refresh_hash__')) == null ? void 0 : _workUnitStore_cookies_get.value : undefined;\n}","map":{"version":3,"names":["getExpectedRequestStore","getHmrRefreshHash","getPrerenderResumeDataCache","getRenderResumeDataCache","workUnitAsyncStorage","_workunitasyncstorageinstance","workUnitAsyncStorageInstance","callingExpression","workUnitStore","getStore","type","Object","defineProperty","Error","prerenderResumeDataCache","renderResumeDataCache","_workUnitStore_cookies_get","hmrRefreshHash","cookies","get","value","undefined"],"sources":["C:\\Users\\DELL\\node_modules\\next\\src\\server\\app-render\\work-unit-async-storage.external.ts"],"sourcesContent":["import type { AsyncLocalStorage } from 'async_hooks'\nimport type { DraftModeProvider } from '../async-storage/draft-mode-provider'\nimport type { ResponseCookies } from '../web/spec-extension/cookies'\nimport type { ReadonlyHeaders } from '../web/spec-extension/adapters/headers'\nimport type { ReadonlyRequestCookies } from '../web/spec-extension/adapters/request-cookies'\nimport type { CacheSignal } from './cache-signal'\nimport type { DynamicTrackingState } from './dynamic-rendering'\n\n// Share the instance module in the next-shared layer\nimport { workUnitAsyncStorageInstance } from './work-unit-async-storage-instance' with { 'turbopack-transition': 'next-shared' }\nimport type { ServerComponentsHmrCache } from '../response-cache'\nimport type {\n  RenderResumeDataCache,\n  PrerenderResumeDataCache,\n} from '../resume-data-cache/resume-data-cache'\nimport type { Params } from '../request/params'\n\ntype WorkUnitPhase = 'action' | 'render' | 'after'\n\ntype PhasePartial = {\n  /** NOTE: Will be mutated as phases change */\n  phase: WorkUnitPhase\n}\n\nexport type RequestStore = {\n  type: 'request'\n\n  /**\n   * The URL of the request. This only specifies the pathname and the search\n   * part of the URL.\n   */\n  readonly url: {\n    /**\n     * The pathname of the requested URL.\n     */\n    readonly pathname: string\n\n    /**\n     * The search part of the requested URL. If the request did not provide a\n     * search part, this will be an empty string.\n     */\n    readonly search: string\n  }\n\n  readonly headers: ReadonlyHeaders\n  // This is mutable because we need to reassign it when transitioning from the action phase to the render phase.\n  // The cookie object itself is deliberately read only and thus can't be updated.\n  cookies: ReadonlyRequestCookies\n  readonly mutableCookies: ResponseCookies\n  readonly userspaceMutableCookies: ResponseCookies\n  readonly draftMode: DraftModeProvider\n  readonly isHmrRefresh?: boolean\n  readonly serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  readonly implicitTags: string[]\n  readonly rootParams: Params\n\n  /**\n   * The resume data cache for this request. This will be a immutable cache.\n   */\n  renderResumeDataCache: RenderResumeDataCache | null\n\n  // DEV-only\n  usedDynamic?: boolean\n  prerenderPhase?: boolean\n} & PhasePartial\n\n/**\n * The Prerender store is for tracking information related to prerenders.\n *\n * It can be used for both RSC and SSR prerendering and should be scoped as close\n * to the individual `renderTo...` API call as possible. To keep the type simple\n * we don't distinguish between RSC and SSR prerendering explicitly but instead\n * use conditional object properties to infer which mode we are in. For instance cache tracking\n * only needs to happen during the RSC prerender when we are prospectively prerendering\n * to fill all caches.\n */\nexport type PrerenderStoreModern = {\n  type: 'prerender'\n  readonly implicitTags: string[]\n\n  /**\n   * This signal is aborted when the React render is complete. (i.e. it is the same signal passed to react)\n   */\n  readonly renderSignal: AbortSignal\n  /**\n   * This is the AbortController which represents the boundary between Prerender and dynamic. In some renders it is\n   * the same as the controller for the renderSignal but in others it is a separate controller. It should be aborted\n   * whenever the we are no longer in the prerender phase of rendering. Typically this is after one task or when you call\n   * a sync API which requires the prerender to end immediately\n   */\n  readonly controller: AbortController\n\n  /**\n   * when not null this signal is used to track cache reads during prerendering and\n   * to await all cache reads completing before aborting the prerender.\n   */\n  readonly cacheSignal: null | CacheSignal\n\n  /**\n   * During some prerenders we want to track dynamic access.\n   */\n  readonly dynamicTracking: null | DynamicTrackingState\n\n  readonly rootParams: Params\n\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache | null\n\n  // DEV ONLY\n  // When used this flag informs certain APIs to skip logging because we're\n  // not part of the primary render path and are just prerendering to produce\n  // validation results\n  validating?: boolean\n} & PhasePartial\n\nexport type PrerenderStorePPR = {\n  type: 'prerender-ppr'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  readonly dynamicTracking: null | DynamicTrackingState\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n\n  /**\n   * The resume data cache for this prerender.\n   */\n  prerenderResumeDataCache: PrerenderResumeDataCache\n} & PhasePartial\n\nexport type PrerenderStoreLegacy = {\n  type: 'prerender-legacy'\n  readonly rootParams: Params\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this document during the prerender.\n  revalidate: number // in seconds. 0 means dynamic. INFINITE_CACHE and higher means never revalidate.\n  expire: number // server expiration time\n  stale: number // client expiration time\n  tags: null | string[]\n} & PhasePartial\n\nexport type PrerenderStore =\n  | PrerenderStoreLegacy\n  | PrerenderStorePPR\n  | PrerenderStoreModern\n\nexport type UseCacheStore = {\n  type: 'cache'\n  readonly implicitTags: string[]\n  // Collected revalidate times and tags for this cache entry during the cache render.\n  revalidate: number // implicit revalidate time from inner caches / fetches\n  expire: number // server expiration time\n  stale: number // client expiration time\n  explicitRevalidate: undefined | number // explicit revalidate time from cacheLife() calls\n  explicitExpire: undefined | number // server expiration time\n  explicitStale: undefined | number // client expiration time\n  tags: null | string[]\n  readonly hmrRefreshHash: string | undefined\n  readonly isHmrRefresh: boolean\n  readonly serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n  readonly forceRevalidate: boolean\n} & PhasePartial\n\nexport type UnstableCacheStore = {\n  type: 'unstable-cache'\n} & PhasePartial\n\n/**\n * The Cache store is for tracking information inside a \"use cache\" or unstable_cache context.\n * Inside this context we should never expose any request or page specific information.\n */\nexport type CacheStore = UseCacheStore | UnstableCacheStore\n\nexport type WorkUnitStore = RequestStore | CacheStore | PrerenderStore\n\nexport type WorkUnitAsyncStorage = AsyncLocalStorage<WorkUnitStore>\n\nexport { workUnitAsyncStorageInstance as workUnitAsyncStorage }\n\nexport function getExpectedRequestStore(\n  callingExpression: string\n): RequestStore {\n  const workUnitStore = workUnitAsyncStorageInstance.getStore()\n  if (workUnitStore) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore\n    }\n    if (\n      workUnitStore.type === 'prerender' ||\n      workUnitStore.type === 'prerender-ppr' ||\n      workUnitStore.type === 'prerender-legacy'\n    ) {\n      // This should not happen because we should have checked it already.\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside a prerender. This is a bug in Next.js.`\n      )\n    }\n    if (workUnitStore.type === 'cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside \"use cache\". Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/messages/next-request-in-use-cache`\n      )\n    } else if (workUnitStore.type === 'unstable-cache') {\n      throw new Error(\n        `\\`${callingExpression}\\` cannot be called inside unstable_cache. Call it outside and pass an argument instead. Read more: https://nextjs.org/docs/app/api-reference/functions/unstable_cache`\n      )\n    }\n  }\n  throw new Error(\n    `\\`${callingExpression}\\` was called outside a request scope. Read more: https://nextjs.org/docs/messages/next-dynamic-api-wrong-context`\n  )\n}\n\nexport function getPrerenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): PrerenderResumeDataCache | null {\n  if (\n    workUnitStore.type === 'prerender' ||\n    workUnitStore.type === 'prerender-ppr'\n  ) {\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getRenderResumeDataCache(\n  workUnitStore: WorkUnitStore\n): RenderResumeDataCache | null {\n  if (\n    workUnitStore.type !== 'prerender-legacy' &&\n    workUnitStore.type !== 'cache' &&\n    workUnitStore.type !== 'unstable-cache'\n  ) {\n    if (workUnitStore.type === 'request') {\n      return workUnitStore.renderResumeDataCache\n    }\n\n    // We return the mutable resume data cache here as an immutable version of\n    // the cache as it can also be used for reading.\n    return workUnitStore.prerenderResumeDataCache\n  }\n\n  return null\n}\n\nexport function getHmrRefreshHash(\n  workUnitStore: WorkUnitStore\n): string | undefined {\n  return workUnitStore.type === 'cache'\n    ? workUnitStore.hmrRefreshHash\n    : workUnitStore.type === 'request'\n      ? workUnitStore.cookies.get('__next_hmr_refresh_hash__')?.value\n      : undefined\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;EA8LgBA,uBAAuB,WAAAA,CAAA;WAAvBA,uBAAA;;EAkEAC,iBAAiB,WAAAA,CAAA;WAAjBA,iBAAA;;EAjCAC,2BAA2B,WAAAA,CAAA;WAA3BA,2BAAA;;EAaAC,wBAAwB,WAAAA,CAAA;WAAxBA,wBAAA;;EAhDyBC,oBAAoB,WAAAA,CAAA;WAApDC,6BAAA,CAAAC,4BAA4B;;;8CAnLQ;AAqLtC,SAASN,wBACdO,iBAAyB;EAEzB,MAAMC,aAAA,GAAgBH,6BAAA,CAAAC,4BAA4B,CAACG,QAAQ;EAC3D,IAAID,aAAA,EAAe;IACjB,IAAIA,aAAA,CAAcE,IAAI,KAAK,WAAW;MACpC,OAAOF,aAAA;IACT;IACA,IACEA,aAAA,CAAcE,IAAI,KAAK,eACvBF,aAAA,CAAcE,IAAI,KAAK,mBACvBF,aAAA,CAAcE,IAAI,KAAK,oBACvB;MACA;MACA,MAAMC,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,KAAKN,iBAAA,mEAAoF,GADrF;eAAA;oBAAA;sBAAA;MAEN;IACF;IACA,IAAIC,aAAA,CAAcE,IAAI,KAAK,SAAS;MAClC,MAAMC,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,KAAKN,iBAAA,6JAA8K,GAD/K;eAAA;oBAAA;sBAAA;MAEN;IACF,OAAO,IAAIC,aAAA,CAAcE,IAAI,KAAK,kBAAkB;MAClD,MAAMC,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,KAAKN,iBAAA,wKAAyL,GAD1L;eAAA;oBAAA;sBAAA;MAEN;IACF;EACF;EACA,MAAMI,MAAA,CAAAC,cAEL,CAFK,IAAIC,KAAA,CACR,KAAKN,iBAAA,mHAAoI,GADrI;WAAA;gBAAA;kBAAA;EAEN;AACF;AAEO,SAASL,4BACdM,aAA4B;EAE5B,IACEA,aAAA,CAAcE,IAAI,KAAK,eACvBF,aAAA,CAAcE,IAAI,KAAK,iBACvB;IACA,OAAOF,aAAA,CAAcM,wBAAwB;EAC/C;EAEA,OAAO;AACT;AAEO,SAASX,yBACdK,aAA4B;EAE5B,IACEA,aAAA,CAAcE,IAAI,KAAK,sBACvBF,aAAA,CAAcE,IAAI,KAAK,WACvBF,aAAA,CAAcE,IAAI,KAAK,kBACvB;IACA,IAAIF,aAAA,CAAcE,IAAI,KAAK,WAAW;MACpC,OAAOF,aAAA,CAAcO,qBAAqB;IAC5C;IAEA;IACA;IACA,OAAOP,aAAA,CAAcM,wBAAwB;EAC/C;EAEA,OAAO;AACT;AAEO,SAASb,kBACdO,aAA4B;MAKtBQ,0BAAA;EAHN,OAAOR,aAAA,CAAcE,IAAI,KAAK,UAC1BF,aAAA,CAAcS,cAAc,GAC5BT,aAAA,CAAcE,IAAI,KAAK,aACrBM,0BAAA,GAAAR,aAAA,CAAcU,OAAO,CAACC,GAAG,CAAC,iDAA1BH,0BAAA,CAAwDI,KAAK,GAC7DC,SAAA;AACR","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}